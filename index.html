<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Houdini VEX 语法练习平台</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0a1929, #0f2d44, #1a3a5f);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(10, 25, 47, 0.8);
            border-radius: 15px;
            border: 1px solid rgba(100, 255, 218, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .logo i {
            font-size: 40px;
            color: #64ffda;
        }
        
        h1 {
            font-size: 36px;
            background: linear-gradient(to right, #64ffda, #4cc9f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 10px rgba(100, 255, 218, 0.2);
        }
        
        .subtitle {
            font-size: 18px;
            color: #ccd6f6;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .editor-section, .preview-section {
            flex: 1;
            min-width: 300px;
            background: rgba(10, 25, 47, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 255, 218, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .section-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100, 255, 218, 0.2);
            color: #64ffda;
        }
        
        .section-title i {
            font-size: 22px;
        }
        
        .vex-editor {
            height: 500px;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }
        
        .CodeMirror {
            height: 100% !important;
            font-size: 15px;
            font-family: 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        
        .CodeMirror-hints {
            background: #0a1929;
            border: 1px solid rgba(100, 255, 218, 0.3);
            border-radius: 5px;
            font-family: 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        
        .CodeMirror-hint {
            color: #ccd6f6;
            padding: 8px 12px;
        }
        
        .CodeMirror-hint-active {
            background: rgba(100, 255, 218, 0.2);
            color: #64ffda;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, #112240, #233554);
            color: #64ffda;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
            border: 1px solid rgba(100, 255, 218, 0.1);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(100, 255, 218, 0.2);
            background: linear-gradient(to right, #1a3a5f, #233554);
        }
        
        button.primary {
            background: linear-gradient(to right, #0a3d62, #1a759f);
            color: white;
        }
        
        button.secondary {
            background: linear-gradient(to right, #4361ee, #4cc9f0);
        }
        
        button.reset {
            background: linear-gradient(to right, #f72585, #b5179e);
        }
        
        .preview-area {
            height: 500px;
            background: #0a1929;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }
        
        .preview-content {
            font-family: 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .error {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            padding: 12px 15px;
            border-radius: 5px;
            border-left: 3px solid #ff6b6b;
            margin-top: 10px;
        }
        
        .success {
            color: #64ffda;
            background: rgba(100, 255, 218, 0.1);
            padding: 12px 15px;
            border-radius: 5px;
            border-left: 3px solid #64ffda;
            margin-top: 10px;
        }
        
        .output-line {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        
        .variable-table {
            margin-top: 15px;
            border-top: 1px solid rgba(100, 255, 218, 0.1);
            padding-top: 15px;
        }
        
        .variable-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .var-name {
            color: #4cc9f0;
            font-weight: 500;
        }
        
        .var-value {
            color: #ccd6f6;
            font-family: 'Fira Code', monospace;
        }
        
        .examples-section, .function-reference {
            width: 100%;
            background: rgba(10, 25, 47, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 255, 218, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-top: 20px;
        }
        
        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .example-card {
            background: rgba(17, 34, 64, 0.6);
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid rgba(100, 255, 218, 0.05);
            display: flex;
            flex-direction: column;
        }
        
        .example-card:hover {
            transform: translateY(-5px);
            background: rgba(100, 255, 218, 0.05);
            border-color: rgba(100, 255, 218, 0.2);
            box-shadow: 0 10px 20px rgba(100, 255, 218, 0.1);
        }
        
        .example-title {
            color: #64ffda;
            font-size: 18px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .example-desc {
            font-size: 14px;
            color: #8892b0;
            line-height: 1.5;
            flex-grow: 1;
        }
        
        .example-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        
        .example-tag {
            background: rgba(100, 255, 218, 0.1);
            color: #64ffda;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 11px;
        }
        
        .function-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .function-item {
            background: rgba(17, 34, 64, 0.6);
            border-radius: 8px;
            padding: 20px;
            font-family: 'Segoe UI', sans-serif;
            border: 1px solid rgba(100, 255, 218, 0.05);
            transition: all 0.2s;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .function-item:hover {
            border-color: rgba(100, 255, 218, 0.2);
            background: rgba(100, 255, 218, 0.05);
            transform: translateY(-2px);
        }
        
        .function-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .function-name {
            color: #64ffda;
            font-weight: 600;
            font-size: 16px;
            font-family: 'Fira Code', monospace;
        }
        
        .function-category {
            color: #8892b0;
            font-size: 11px;
            background: rgba(100, 255, 218, 0.1);
            padding: 3px 8px;
            border-radius: 10px;
            white-space: nowrap;
        }
        
        .function-desc {
            color: #ccd6f6;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .function-syntax {
            color: #8892b0;
            font-size: 13px;
            font-family: 'Fira Code', monospace;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border-left: 3px solid #4cc9f0;
        }
        
        .function-example {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 12px;
            font-size: 13px;
            font-family: 'Fira Code', monospace;
            color: #8892b0;
            border: 1px solid rgba(100, 255, 218, 0.1);
            max-height: 150px;
            overflow-y: auto;
            line-height: 1.4;
        }
        
        .example-comment {
            color: #6c757d;
            font-style: italic;
        }
        
        .example-code {
            color: #64ffda;
        }
        
        .example-output {
            color: #4cc9f0;
        }
        
        .function-actions {
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }
        
        .function-btn {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
            background: rgba(100, 255, 218, 0.1);
            color: #64ffda;
            cursor: pointer;
            border: 1px solid rgba(100, 255, 218, 0.2);
            transition: all 0.2s;
        }
        
        .function-btn:hover {
            background: rgba(100, 255, 218, 0.2);
        }
        
        .tab-container {
            margin-top: 20px;
            border-bottom: 1px solid rgba(100, 255, 218, 0.1);
        }
        
        .tabs {
            display: flex;
            gap: 5px;
            overflow-x: auto;
        }
        
        .tab {
            padding: 10px 20px;
            background: rgba(17, 34, 64, 0.6);
            border: 1px solid rgba(100, 255, 218, 0.05);
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            color: #8892b0;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .tab.active {
            background: rgba(100, 255, 218, 0.1);
            color: #64ffda;
            border-color: rgba(100, 255, 218, 0.2);
        }
        
        .tab-content {
            display: none;
            padding: 20px 0;
        }
        
        .tab-content.active {
            display: block;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            color: #64ffda;
            font-size: 14px;
            border-top: 1px solid rgba(100, 255, 218, 0.1);
        }
        
        .shortcut-hint {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            color: #8892b0;
            font-size: 13px;
        }
        
        .shortcut-key {
            background: rgba(100, 255, 218, 0.1);
            color: #64ffda;
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .editor-section, .preview-section {
                width: 100%;
            }
            
            .vex-editor, .preview-area {
                height: 400px;
            }
            
            .examples-grid, .function-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .var-declaration {
            color: #4cc9f0;
        }
        
        .vex-keyword {
            color: #ff6b6b;
        }
        
        .vex-function {
            color: #64ffda;
        }
        
        .vex-number {
            color: #9d4edd;
        }
        
        .vex-string {
            color: #2a9d8f;
        }
        
        .vex-comment {
            color: #6c757d;
            font-style: italic;
        }
        
        .vex-operator {
            color: #ffd166;
        }
        
        .vex-type {
            color: #f72585;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-code"></i>
                <h1>Houdini VEX 语法练习平台</h1>
            </div>
            <p class="subtitle">在浏览器中直接练习和运行VEX代码。支持代码自动补全、语法高亮和丰富的VEX函数库。</p>
            <div class="shortcut-hint">
                <span>代码补全: <span class="shortcut-key">Ctrl+Space</span></span>
                <span>运行代码: <span class="shortcut-key">Ctrl+Enter</span></span>
                <span>格式化: <span class="shortcut-key">Ctrl+Shift+F</span></span>
            </div>
        </header>
        
        <div class="main-content">
            <div class="editor-section">
                <div class="section-title">
                    <i class="fas fa-code"></i>
                    <h2>VEX 代码编辑器</h2>
                </div>
                
                <div class="vex-editor" id="vexEditor"></div>
                
                <div class="controls">
                    <button id="runBtn" class="primary">
                        <i class="fas fa-play"></i> 运行代码 (Ctrl+Enter)
                    </button>
                    <button id="clearBtn" class="reset">
                        <i class="fas fa-broom"></i> 清空结果
                    </button>
                    <button id="formatBtn" class="secondary">
                        <i class="fas fa-align-left"></i> 格式化代码
                    </button>
                    <button id="hintBtn">
                        <i class="fas fa-lightbulb"></i> 显示提示
                    </button>
                </div>
            </div>
            
            <div class="preview-section">
                <div class="section-title">
                    <i class="fas fa-eye"></i>
                    <h2>运行结果</h2>
                </div>
                
                <div class="preview-area">
                    <div class="preview-content" id="previewContent">
                        <div class="output-line">// 运行结果将显示在这里</div>
                        <div class="output-line">// 点击"运行代码"按钮或按Ctrl+Enter执行VEX代码</div>
                    </div>
                </div>
                
                <div id="outputInfo"></div>
            </div>
        </div>
        
        <div class="examples-section">
            <div class="section-title">
                <i class="fas fa-graduation-cap"></i>
                <h2>VEX 示例代码</h2>
            </div>
            
            <div class="examples-grid" id="examplesGrid">
                <!-- 示例代码将通过JavaScript动态生成 -->
            </div>
        </div>
        
        <div class="function-reference">
            <div class="section-title">
                <i class="fas fa-book"></i>
                <h2>VEX 函数参考库</h2>
            </div>
            
            <div class="tab-container">
                <div class="tabs" id="functionTabs">
                    <!-- 标签页将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <!-- 新增的标签页内容 -->
            <div class="tab-content active" id="math-tab">
                <div class="function-grid" id="mathFunctions">
                    <!-- 数学函数将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <div class="tab-content" id="vector-tab">
                <div class="function-grid" id="vectorFunctions">
                    <!-- 向量函数将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <div class="tab-content" id="matrix-tab">
                <div class="function-grid" id="matrixFunctions">
                    <!-- 矩阵函数将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <div class="tab-content" id="array-tab">
                <div class="function-grid" id="arrayFunctions">
                    <!-- 数组函数将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <div class="tab-content" id="string-tab">
                <div class="function-grid" id="stringFunctions">
                    <!-- 字符串函数将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <div class="tab-content" id="quaternion-tab">
                <div class="function-grid" id="quaternionFunctions">
                    <!-- 四元数函数将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <div class="tab-content" id="random-tab">
                <div class="function-grid" id="randomFunctions">
                    <!-- 随机函数将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <div class="tab-content" id="noise-tab">
                <div class="function-grid" id="noiseFunctions">
                    <!-- 噪声函数将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <div class="tab-content" id="conversion-tab">
                <div class="function-grid" id="conversionFunctions">
                    <!-- 转换函数将通过JavaScript动态生成 -->
                </div>
            </div>
        </div>
        
        <footer>
            <p>© 2023 Houdini VEX 练习平台 | 本工具模拟VEX执行环境，用于学习VEX语法。实际开发请使用Houdini软件。</p>
        </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/clike/clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/anyword-hint.min.js"></script>
    <script>
        // 扩展VEX关键词和函数库用于自动补全
        const vexKeywords = [
            "int", "float", "vector", "vector2", "vector4", "matrix", "matrix3", 
            "string", "array", "dict", "void", "return", "if", "else", "for", 
            "while", "break", "continue", "switch", "case", "default", "printf",
            "export", "import", "include", "define", "struct", "typedef",
            "for", "foreach", "while", "do", "break", "continue", "return"
        ];
        
        const vexFunctions = [
            // 数学函数
            "abs", "acos", "asin", "atan", "atan2", "ceil", "cos", "cosh", 
            "exp", "floor", "log", "log10", "max", "min", "pow", "sin", "sinh", 
            "sqrt", "tan", "tanh", "trunc", "fit", "fit01", "fit10", "fit11",
            "clamp", "floor", "ceil", "round", "sign", "fmod", "mod", "lerp",
            "smooth", "smoothstep", "noise", "anoise", "pnoise", "curlnoise",
            "random", "rand", "shrink", "expand", "hypot", "cbrt", "erf", "erfc",
            "gamma", "lgamma", "isfinite", "isnan", "isinf", "rint",
            
            // 向量函数
            "length", "length2", "normalize", "distance", "dot", "cross", 
            "determinant", "eigenvalues", "eigenvectors", "luminance",
            "rotate", "reflect", "refract", "orient", "dihedral", 
            "lookat", "translate", "scale", "rotate", "shear", 
            "ident", "invert", "transpose", "multiply", "det", "set",
            "qconvert", "qmultiply", "qslerp", "qinvert", "qrotate",
            
            // 数组函数
            "len", "resize", "push", "pop", "insert", "remove", "removeindex",
            "find", "sort", "argsort", "reverse", "slice", "concatenate",
            "min", "max", "sum", "avg", "median", "variance", "stdev",
            "union", "intersect", "difference", "unique", "append",
            
            // 矩阵函数
            "maketransform", "cracktransform", "ident", "invert", "transpose",
            "determinant", "diagonal", "eigenvalues", "eigenvectors", "polardecomp",
            "outerproduct", "matrix", "setcomp", "getcomp", "diag", "trace",
            "mattrib", "hasattrib", "removeattrib", "rot", "scale", "translate",
            
            // 四元数函数
            "quaternion", "qconvert", "qmultiply", "qslerp", "qinvert", "qrotate",
            "qdot", "qlength", "qnormalize", "qslerp", "qdistance",
            "qtoeuler", "qtomatrix", "qfromeuler", "qfromaxisangle",
            
            // 字符串函数
            "itoa", "atoi", "ftoa", "atof", "split", "join", "substr",
            "strlen", "strcmp", "toupper", "tolower", "match", "replace",
            "sprintf", "printf", "warning", "error", "ch", "chr", "ord",
            "strcat", "strfind", "strrfind", "strlstrip", "strrstrip", "strstrip",
            
            // 随机函数
            "random", "rand", "random_fhash", "random_ihash", "random_shash",
            "random_poisson", "random_linear_congruential", "random_permutation",
            
            // 噪声函数
            "noise", "anoise", "pnoise", "curlnoise", "curlnoise2d", "vnoise",
            "fbm", "turbulence", "cellnoise", "cellnoise3", "cellnoise4",
            "snoise", "vsnoise", "flownoise", "alligator", "gnoise",
            
            // 转换函数
            "deg", "rad", "toNDC", "fromNDC", "hsvtorgb", "rgbtolab",
            "labtorgb", "xyztorgb", "rgbtocmyk", "cmyktorgb", 
            "ctransform", "cspace", "ocio_transform", "rgbtohsv",
            
            // 几何函数
            "addpoint", "addprim", "addvertex", "removepoint", "removeprim",
            "setpointattrib", "setprimattrib", "setvertexattrib", "setdetailattrib",
            "getpointattrib", "getprimattrib", "getvertexattrib", "getdetailattrib",
            "nearpoint", "nearpoints", "minpos", "intersect", "uvintersect",
            "prim", "vertex", "point", "detail", "hedge", "edge", "neighbour",
            
            // 日期时间函数
            "time", "ctime", "localtime", "strftime", "mktime"
        ];
        
        // 完整的VEX自动补全词库
        const vexAutocomplete = [...vexKeywords, ...vexFunctions];
        
        // 自定义VEX代码提示
        CodeMirror.registerHelper("hint", "vex", function(editor, options) {
            const cursor = editor.getCursor();
            const token = editor.getTokenAt(cursor);
            const start = token.start;
            const end = cursor.ch;
            const line = cursor.line;
            const currentWord = token.string;
            
            let list = [];
            
            // 根据当前输入筛选匹配项
            vexAutocomplete.forEach(item => {
                if (item.toLowerCase().startsWith(currentWord.toLowerCase())) {
                    list.push(item);
                }
            });
            
            // 添加常用变量模式
            if (currentWord.length > 0) {
                list.push(`@${currentWord}`, `$${currentWord}`, `v@${currentWord}`, `p@${currentWord}`);
            }
            
            // 如果列表为空，显示所有选项
            if (list.length === 0) {
                list = vexAutocomplete;
            }
            
            return {
                list: list,
                from: CodeMirror.Pos(line, start),
                to: CodeMirror.Pos(line, end)
            };
        });

        // 初始化代码编辑器
        const editor = CodeMirror(document.getElementById('vexEditor'), {
            mode: 'text/x-c',
            theme: 'monokai',
            lineNumbers: true,
            lineWrapping: true,
            indentUnit: 4,
            tabSize: 4,
            extraKeys: {
                "Ctrl-Space": function(cm) {
                    cm.showHint({
                        hint: CodeMirror.hint.vex,
                        completeSingle: false
                    });
                },
                "Ctrl-Enter": function() {
                    runCode();
                },
                "Ctrl-Shift-F": function(cm) {
                    formatCode();
                }
            },
            value: `// Houdini VEX 代码示例 - 支持自动补全(Ctrl+Space)
// 点击"运行代码"按钮或按Ctrl+Enter执行

// 1. 定义变量 (输入"int "后按Ctrl+Space)
int count = 10;
float pi = 3.14159;
vector pos = {0, 1, 2};
string message = "Hello VEX!";
matrix3 rot = ident();

// 2. 输出变量值
printf("整数 count = %d\\n", count);
printf("浮点数 pi = %.3f\\n", pi);
printf("向量 pos = %g\\n", pos);
printf("字符串 message = %s\\n", message);

// 3. 数学运算
float radius = 5.0;
float area = pi * radius * radius;
printf("半径为%.1f的圆面积 = %.2f\\n", radius, area);

// 4. 向量运算
vector a = {1, 2, 3};
vector b = {4, 5, 6};
vector sum = a + b;
vector cross_product = cross(a, b);
float dot_product = dot(a, b);
printf("向量 a + b = %g\\n", sum);
printf("向量 a × b = %g\\n", cross_product);
printf("向量 a · b = %.2f\\n", dot_product);

// 5. 矩阵运算
matrix3 m1 = ident();
matrix3 m2 = { {1,2,3}, {4,5,6}, {7,8,9} };
matrix3 m3 = m1 * m2;
printf("矩阵 m3 = %g\\n", m3);

// 6. 数组操作
float values[] = {1.2, 3.4, 5.6, 7.8};
printf("数组 values 有 %d 个元素\\n", len(values));
for(int i = 0; i < len(values); i++) {
    printf("  values[%d] = %.1f\\n", i, values[i]);
}

// 7. 条件语句
if (length(pos) > 0) {
    printf("向量pos的长度大于0\\n");
} else {
    printf("向量pos的长度为0\\n");
}

// 8. 循环 - 生成斐波那契数列
int fib_count = 10;
int fib[] = {0, 1};
for(int i = 2; i < fib_count; i++) {
    append(fib, fib[i-1] + fib[i-2]);
}
printf("斐波那契数列前%d项: %g\\n", fib_count, fib);`
        });

        // DOM元素
        const runBtn = document.getElementById('runBtn');
        const clearBtn = document.getElementById('clearBtn');
        const formatBtn = document.getElementById('formatBtn');
        const hintBtn = document.getElementById('hintBtn');
        const previewContent = document.getElementById('previewContent');
        const outputInfo = document.getElementById('outputInfo');
        const examplesGrid = document.getElementById('examplesGrid');
        const functionTabs = document.getElementById('functionTabs');
        
        // 标签页内容容器
        const tabContents = {
            'math-tab': document.getElementById('math-tab'),
            'vector-tab': document.getElementById('vector-tab'),
            'matrix-tab': document.getElementById('matrix-tab'),
            'array-tab': document.getElementById('array-tab'),
            'string-tab': document.getElementById('string-tab'),
            'quaternion-tab': document.getElementById('quaternion-tab'),
            'random-tab': document.getElementById('random-tab'),
            'noise-tab': document.getElementById('noise-tab'),
            'conversion-tab': document.getElementById('conversion-tab')
        };

        // VEX模拟执行器（增强版）
        class VEXSimulator {
            constructor() {
                this.variables = {};
                this.output = [];
                this.error = null;
                this.functionImplementations = this._createFunctionImplementations();
            }
            
            _createFunctionImplementations() {
                return {
                    // 数学函数
                    'abs': (x) => Math.abs(x),
                    'sin': (x) => Math.sin(x),
                    'cos': (x) => Math.cos(x),
                    'tan': (x) => Math.tan(x),
                    'asin': (x) => Math.asin(x),
                    'acos': (x) => Math.acos(x),
                    'atan': (x) => Math.atan(x),
                    'atan2': (y, x) => Math.atan2(y, x),
                    'sqrt': (x) => Math.sqrt(x),
                    'exp': (x) => Math.exp(x),
                    'log': (x) => Math.log(x),
                    'log10': (x) => Math.log10(x),
                    'pow': (x, y) => Math.pow(x, y),
                    'floor': (x) => Math.floor(x),
                    'ceil': (x) => Math.ceil(x),
                    'round': (x) => Math.round(x),
                    'clamp': (x, min, max) => Math.max(min, Math.min(max, x)),
                    'lerp': (a, b, t) => a + (b - a) * t,
                    'min': (...args) => Math.min(...args),
                    'max': (...args) => Math.max(...args),
                    'fit': (value, oldmin, oldmax, newmin, newmax) => 
                        newmin + (newmax - newmin) * ((value - oldmin) / (oldmax - oldmin)),
                    'sign': (x) => x > 0 ? 1 : x < 0 ? -1 : 0,
                    'fmod': (x, y) => x % y,
                    'mod': (x, y) => ((x % y) + y) % y,
                    'hypot': (x, y) => Math.sqrt(x * x + y * y),
                    'cbrt': (x) => Math.cbrt(x),
                    
                    // 向量函数
                    'length': (v) => {
                        if (Array.isArray(v)) {
                            return Math.sqrt(v.reduce((sum, val) => sum + val * val, 0));
                        }
                        return Math.abs(v);
                    },
                    'normalize': (v) => {
                        if (Array.isArray(v)) {
                            const len = this.functionImplementations['length'](v);
                            return v.map(val => val / len);
                        }
                        return v;
                    },
                    'dot': (a, b) => {
                        if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {
                            return a.reduce((sum, val, i) => sum + val * b[i], 0);
                        }
                        return a * b;
                    },
                    'cross': (a, b) => {
                        if (Array.isArray(a) && Array.isArray(b) && a.length === 3 && b.length === 3) {
                            return [
                                a[1]*b[2] - a[2]*b[1],
                                a[2]*b[0] - a[0]*b[2],
                                a[0]*b[1] - a[1]*b[0]
                            ];
                        }
                        return 0;
                    },
                    'distance': (a, b) => {
                        if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {
                            const diff = a.map((val, i) => val - b[i]);
                            return this.functionImplementations['length'](diff);
                        }
                        return Math.abs(a - b);
                    },
                    'luminance': (color) => {
                        if (Array.isArray(color) && color.length >= 3) {
                            return 0.2126*color[0] + 0.7152*color[1] + 0.0722*color[2];
                        }
                        return color;
                    },
                    
                    // 数组函数
                    'len': (arr) => {
                        if (Array.isArray(arr)) return arr.length;
                        return 1;
                    },
                    'append': (arr, value) => {
                        if (Array.isArray(arr)) {
                            arr.push(value);
                            return arr;
                        }
                        return [arr, value];
                    },
                    'resize': (arr, size, defaultValue = 0) => {
                        if (!Array.isArray(arr)) return Array(size).fill(defaultValue);
                        if (arr.length === size) return arr;
                        if (arr.length > size) return arr.slice(0, size);
                        return arr.concat(Array(size - arr.length).fill(defaultValue));
                    },
                    'sort': (arr) => {
                        if (!Array.isArray(arr)) return [arr];
                        return [...arr].sort((a, b) => a - b);
                    },
                    'reverse': (arr) => {
                        if (!Array.isArray(arr)) return [arr];
                        return [...arr].reverse();
                    },
                    'sum': (arr) => {
                        if (!Array.isArray(arr)) return arr;
                        return arr.reduce((sum, val) => sum + val, 0);
                    },
                    'avg': (arr) => {
                        if (!Array.isArray(arr)) return arr;
                        return arr.reduce((sum, val) => sum + val, 0) / arr.length;
                    },
                    'find': (arr, value) => {
                        if (!Array.isArray(arr)) return -1;
                        return arr.indexOf(value);
                    },
                    
                    // 字符串函数
                    'strlen': (str) => {
                        return str.length;
                    },
                    'toupper': (str) => {
                        return str.toUpperCase();
                    },
                    'tolower': (str) => {
                        return str.toLowerCase();
                    },
                    'split': (str, delimiter) => {
                        return str.split(delimiter);
                    },
                    'join': (arr, delimiter) => {
                        if (Array.isArray(arr)) {
                            return arr.join(delimiter);
                        }
                        return String(arr);
                    },
                    
                    // 随机函数
                    'random': (min = 0, max = 1) => {
                        return min + Math.random() * (max - min);
                    },
                    'rand': (seed) => {
                        // 简单的伪随机数生成
                        const x = Math.sin(seed || Math.random() * 1000) * 10000;
                        return x - Math.floor(x);
                    },
                    
                    // 四元数函数（简化实现）
                    'quaternion': (x, y, z, w) => {
                        return [x, y, z, w];
                    },
                    'qlength': (q) => {
                        if (Array.isArray(q) && q.length === 4) {
                            return Math.sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
                        }
                        return 1;
                    },
                    'qnormalize': (q) => {
                        if (Array.isArray(q) && q.length === 4) {
                            const len = this.functionImplementations['qlength'](q);
                            return q.map(val => val / len);
                        }
                        return q;
                    },
                    'qdot': (q1, q2) => {
                        if (Array.isArray(q1) && Array.isArray(q2) && q1.length === 4 && q2.length === 4) {
                            return q1[0]*q2[0] + q1[1]*q2[1] + q1[2]*q2[2] + q1[3]*q2[3];
                        }
                        return 0;
                    }
                };
            }
            
            execute(code) {
                this.output = [];
                this.error = null;
                this.variables = {};
                
                try {
                    this._executeCode(code);
                    return { success: true, output: this.output };
                } catch (error) {
                    this.error = error.message;
                    return { success: false, output: this.output, error: this.error };
                }
            }
            
            _executeCode(code) {
                // 增强的代码解析和执行
                const lines = code.split('\n');
                let inBlockComment = false;
                
                for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
                    let line = lines[lineIdx].trim();
                    
                    // 处理块注释
                    if (line.includes('/*')) {
                        inBlockComment = true;
                    }
                    if (line.includes('*/')) {
                        inBlockComment = false;
                        continue;
                    }
                    if (inBlockComment) continue;
                    
                    // 跳过空行和单行注释
                    if (!line || line.startsWith('//')) {
                        continue;
                    }
                    
                    // 处理函数调用
                    if (line.includes('(') && line.includes(')')) {
                        // 处理printf
                        if (line.includes('printf(')) {
                            this._processPrintf(line);
                            continue;
                        }
                        
                        // 处理其他函数调用
                        this._processFunctionCall(line);
                        continue;
                    }
                    
                    // 处理变量声明和赋值
                    if (line.includes('=')) {
                        this._processAssignment(line);
                        continue;
                    }
                    
                    // 处理控制结构
                    if (line.startsWith('for(') || line.startsWith('for (')) {
                        this._processForLoop(line, lines, lineIdx);
                        continue;
                    }
                    
                    if (line.startsWith('if(') || line.startsWith('if (')) {
                        this._processIfStatement(line, lines, lineIdx);
                        continue;
                    }
                    
                    if (line.startsWith('while(') || line.startsWith('while (')) {
                        this._processWhileLoop(line, lines, lineIdx);
                        continue;
                    }
                }
            }
            
            _processPrintf(line) {
                // 增强的printf处理
                const match = line.match(/printf\s*\(\s*"([^"]*)"\s*(?:,\s*([^)]*))?\)\s*;/);
                if (!match) return;
                
                let format = match[1];
                const args = match[2] ? match[2].split(',').map(arg => this._evaluateExpression(arg.trim())) : [];
                
                // 替换转义字符
                format = format.replace(/\\n/g, '\n').replace(/\\t/g, '\t');
                
                // 处理格式符
                let output = format;
                let argIndex = 0;
                
                // 查找并替换所有格式符
                const formatSpecifiers = format.match(/%[dfgs.0-9]*[dfgs]/g) || [];
                
                for (const specifier of formatSpecifiers) {
                    if (argIndex >= args.length) break;
                    
                    let value = args[argIndex];
                    let formattedValue = value;
                    
                    // 根据格式符格式化值
                    if (specifier.includes('d')) {
                        formattedValue = Math.floor(value);
                    } else if (specifier.includes('f')) {
                        // 查找精度
                        const precisionMatch = specifier.match(/\.(\d+)/);
                        if (precisionMatch) {
                            formattedValue = Number(value).toFixed(parseInt(precisionMatch[1]));
                        } else {
                            formattedValue = Number(value);
                        }
                    } else if (specifier.includes('g')) {
                        // 向量/矩阵/数组输出
                        if (Array.isArray(value)) {
                            if (value.length === 9 || value.length === 16) {
                                // 矩阵
                                formattedValue = '矩阵[' + value.length + ']';
                            } else {
                                formattedValue = '{' + value.join(', ') + '}';
                            }
                        }
                    } else if (specifier.includes('s')) {
                        // 字符串
                        formattedValue = String(value);
                    }
                    
                    output = output.replace(specifier, formattedValue);
                    argIndex++;
                }
                
                this.output.push(output);
            }
            
            _processFunctionCall(line) {
                // 处理函数调用
                const match = line.match(/(\w+)\s*\(([^)]*)\)/);
                if (!match) return;
                
                const funcName = match[1];
                const argsStr = match[2];
                
                // 如果函数有实现，执行它
                if (this.functionImplementations[funcName]) {
                    const args = argsStr.split(',').map(arg => this._evaluateExpression(arg.trim()));
                    return this.functionImplementations[funcName](...args);
                }
                
                // 对于未实现的函数，输出模拟结果
                this.output.push(`[函数调用] ${funcName}(${argsStr})`);
                return 0;
            }
            
            _processAssignment(line) {
                // 增强的赋值处理
                const parts = line.split('=').map(part => part.trim());
                if (parts.length < 2) return;
                
                const leftSide = parts[0];
                const rightSide = parts.slice(1).join('=');
                
                // 检查是否是声明
                const typeMatch = leftSide.match(/^(int|float|vector|vector2|vector4|matrix|matrix3|string|float\s*\[\]|int\s*\[\])\s+(\w+)/);
                
                if (typeMatch) {
                    // 变量声明
                    const type = typeMatch[1].trim();
                    const name = typeMatch[2];
                    const value = this._evaluateExpression(rightSide.replace(';', ''));
                    
                    this.variables[name] = { type, value };
                } else {
                    // 变量赋值
                    const name = leftSide.replace(';', '');
                    const value = this._evaluateExpression(rightSide.replace(';', ''));
                    
                    if (this.variables[name]) {
                        this.variables[name].value = value;
                    } else {
                        // 推断类型
                        let type = 'float';
                        if (typeof value === 'string') type = 'string';
                        else if (Array.isArray(value)) {
                            if (value.length === 2) type = 'vector2';
                            else if (value.length === 3) type = 'vector';
                            else if (value.length === 4) type = 'vector4';
                            else if (value.length === 9) type = 'matrix3';
                            else if (value.length === 16) type = 'matrix';
                            else type = 'float[]';
                        }
                        else if (Number.isInteger(value)) type = 'int';
                        
                        this.variables[name] = { type, value };
                    }
                }
            }
            
            _processForLoop(line, lines, lineIdx) {
                // 简化版for循环处理
                const match = line.match(/for\s*\(\s*(.*?)\s*;\s*(.*?)\s*;\s*(.*?)\s*\)/);
                if (!match) return;
                
                const init = match[1];
                const condition = match[2];
                const update = match[3];
                
                // 执行初始化
                if (init.includes('=')) {
                    this._processAssignment(init + ';');
                }
                
                // 执行循环体
                let loopCount = 0;
                const maxLoops = 1000; // 安全限制
                
                while (this._evaluateCondition(condition) && loopCount < maxLoops) {
                    // 查找循环体
                    let bodyStart = lineIdx;
                    let braceCount = 0;
                    let bodyLines = [];
                    
                    // 查找开括号
                    const openBracePos = line.indexOf('{');
                    if (openBracePos !== -1) {
                        braceCount++;
                        bodyLines.push(line.substring(openBracePos + 1));
                    }
                    
                    // 继续查找直到匹配的闭括号
                    for (let i = lineIdx + 1; i < lines.length && braceCount > 0; i++) {
                        const currentLine = lines[i];
                        for (let j = 0; j < currentLine.length; j++) {
                            if (currentLine[j] === '{') braceCount++;
                            else if (currentLine[j] === '}') braceCount--;
                        }
                        if (braceCount > 0) {
                            bodyLines.push(currentLine);
                        }
                    }
                    
                    // 执行循环体
                    const bodyCode = bodyLines.join('\n');
                    if (bodyCode.trim()) {
                        this._executeCode(bodyCode);
                    }
                    
                    // 执行更新表达式
                    if (update.includes('++')) {
                        const varName = update.replace('++', '').trim();
                        if (this.variables[varName]) {
                            this.variables[varName].value++;
                        }
                    } else if (update.includes('=')) {
                        this._processAssignment(update + ';');
                    }
                    
                    loopCount++;
                }
                
                if (loopCount >= maxLoops) {
                    this.output.push('[警告] 循环可能无限，已中断');
                }
            }
            
            _processIfStatement(line, lines, lineIdx) {
                const match = line.match(/if\s*\(\s*(.+)\s*\)/);
                if (!match) return;
                
                const condition = match[1];
                const conditionResult = this._evaluateCondition(condition);
                
                if (conditionResult) {
                    // 执行if体
                    const openBracePos = line.indexOf('{');
                    if (openBracePos !== -1) {
                        const body = line.substring(openBracePos + 1);
                        if (body.trim()) {
                            this._executeCode(body);
                        }
                    }
                }
            }
            
            _processWhileLoop(line, lines, lineIdx) {
                // 简化版while循环处理
                const match = line.match(/while\s*\(\s*(.+)\s*\)/);
                if (!match) return;
                
                const condition = match[1];
                let loopCount = 0;
                const maxLoops = 1000;
                
                while (this._evaluateCondition(condition) && loopCount < maxLoops) {
                    // 查找并执行循环体
                    const openBracePos = line.indexOf('{');
                    if (openBracePos !== -1) {
                        const body = line.substring(openBracePos + 1);
                        if (body.trim()) {
                            this._executeCode(body);
                        }
                    }
                    
                    loopCount++;
                }
                
                if (loopCount >= maxLoops) {
                    this.output.push('[警告] while循环可能无限，已中断');
                }
            }
            
            _evaluateExpression(expr) {
                expr = expr.trim();
                
                // 移除末尾分号
                if (expr.endsWith(';')) {
                    expr = expr.substring(0, expr.length - 1);
                }
                
                // 字符串
                if (expr.startsWith('"') && expr.endsWith('"')) {
                    return expr.substring(1, expr.length - 1);
                }
                
                // 向量/矩阵/数组
                if (expr.startsWith('{') && expr.endsWith('}')) {
                    const inner = expr.substring(1, expr.length - 1);
                    // 检查是否是矩阵（嵌套数组）
                    if (inner.includes('{')) {
                        // 简单处理，返回字符串表示
                        return `矩阵: ${expr}`;
                    }
                    
                    // 解析数字数组
                    const values = inner.split(',').map(v => {
                        const trimmed = v.trim();
                        const num = parseFloat(trimmed);
                        return isNaN(num) ? trimmed : num;
                    });
                    return values;
                }
                
                // 函数调用
                if (expr.includes('(') && expr.includes(')')) {
                    return this._processFunctionCall(expr);
                }
                
                // 数学表达式
                if (expr.match(/[+\-*/%]/)) {
                    try {
                        // 替换变量名
                        let evalExpr = expr;
                        for (const [name, varInfo] of Object.entries(this.variables)) {
                            const regex = new RegExp(`\\b${name}\\b`, 'g');
                            let replacement = varInfo.value;
                            if (Array.isArray(replacement)) {
                                replacement = JSON.stringify(replacement);
                            }
                            evalExpr = evalExpr.replace(regex, replacement);
                        }
                        
                        // 安全计算表达式
                        return eval(evalExpr);
                    } catch (e) {
                        return 0;
                    }
                }
                
                // 变量
                if (this.variables[expr]) {
                    return this.variables[expr].value;
                }
                
                // 数字
                if (!isNaN(parseFloat(expr))) {
                    return parseFloat(expr);
                }
                
                return expr;
            }
            
            _evaluateCondition(cond) {
                cond = cond.trim();
                
                // 替换变量
                for (const [name, varInfo] of Object.entries(this.variables)) {
                    const regex = new RegExp(`\\b${name}\\b`, 'g');
                    cond = cond.replace(regex, varInfo.value);
                }
                
                // 替换运算符
                cond = cond.replace(/\s*>\s*/g, ' > ');
                cond = cond.replace(/\s*<\s*/g, ' < ');
                cond = cond.replace(/\s*>=\s*/g, ' >= ');
                cond = cond.replace(/\s*<=\s*/g, ' <= ');
                cond = cond.replace(/\s*==\s*/g, ' === ');
                cond = cond.replace(/\s*!=\s*/g, ' !== ');
                cond = cond.replace(/\s*&&\s*/g, ' && ');
                cond = cond.replace(/\s*\|\|\s*/g, ' || ');
                
                try {
                    return eval(cond);
                } catch (e) {
                    return false;
                }
            }
        }

        // 初始化VEX模拟器
        const vexSimulator = new VEXSimulator();

        // 运行代码函数
        function runCode() {
            const code = editor.getValue();
            const result = vexSimulator.execute(code);
            
            // 清空预览区
            previewContent.innerHTML = '';
            
            // 显示输出
            if (result.success) {
                result.output.forEach(line => {
                    const lineElement = document.createElement('div');
                    lineElement.className = 'output-line';
                    lineElement.textContent = line;
                    previewContent.appendChild(lineElement);
                });
                
                // 显示变量表
                const variables = vexSimulator.variables;
                if (Object.keys(variables).length > 0) {
                    const varTitle = document.createElement('div');
                    varTitle.className = 'output-line';
                    varTitle.innerHTML = '<br><strong>变量表:</strong>';
                    previewContent.appendChild(varTitle);
                    
                    const varTable = document.createElement('div');
                    varTable.className = 'variable-table';
                    
                    for (const [name, info] of Object.entries(variables)) {
                        const varElement = document.createElement('div');
                        varElement.className = 'variable-item';
                        
                        let valueStr = info.value;
                        if (Array.isArray(info.value)) {
                            valueStr = `{${info.value.join(', ')}}`;
                        }
                        
                        varElement.innerHTML = `
                            <span class="var-name">${info.type} ${name}</span>
                            <span class="var-value">= ${valueStr}</span>
                        `;
                        varTable.appendChild(varElement);
                    }
                    
                    previewContent.appendChild(varTable);
                }
                
                // 显示成功信息
                outputInfo.innerHTML = `<div class="success">✓ VEX代码执行成功，输出了${result.output.length}行结果</div>`;
            } else {
                // 显示错误信息
                result.output.forEach(line => {
                    const lineElement = document.createElement('div');
                    lineElement.className = 'output-line';
                    lineElement.textContent = line;
                    previewContent.appendChild(lineElement);
                });
                
                outputInfo.innerHTML = `<div class="error">✗ 执行出错: ${result.error}</div>`;
            }
            
            // 滚动到底部
            previewContent.scrollTop = previewContent.scrollHeight;
        }

        // 格式化代码函数
        function formatCode() {
            let code = editor.getValue();
            
            // 添加缩进
            let indentLevel = 0;
            const lines = code.split('\n');
            const formattedLines = [];
            
            for (let line of lines) {
                const trimmedLine = line.trim();
                
                // 减少缩进级别
                if (trimmedLine.startsWith('}') || trimmedLine.startsWith('} else')) {
                    indentLevel--;
                }
                
                // 添加缩进
                const indent = '    '.repeat(Math.max(0, indentLevel));
                formattedLines.push(indent + trimmedLine);
                
                // 增加缩进级别
                if (trimmedLine.endsWith('{')) {
                    indentLevel++;
                }
            }
            
            editor.setValue(formattedLines.join('\n'));
            outputInfo.innerHTML = '<div class="success">✓ 代码已格式化</div>';
        }

        // 事件监听器
        runBtn.addEventListener('click', runCode);
        
        clearBtn.addEventListener('click', () => {
            previewContent.innerHTML = '<div class="output-line">// 运行结果已清空</div>';
            outputInfo.innerHTML = '';
        });
        
        formatBtn.addEventListener('click', formatCode);
        
        hintBtn.addEventListener('click', () => {
            editor.showHint({
                hint: CodeMirror.hint.vex,
                completeSingle: false
            });
        });

        // 全局快捷键
        document.addEventListener('keydown', (e) => {
            // Ctrl+Enter 运行代码
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                runCode();
            }
            
            // Ctrl+Shift+F 格式化代码
            if (e.ctrlKey && e.shiftKey && e.key === 'F') {
                e.preventDefault();
                formatCode();
            }
            
            // Ctrl+Space 代码提示（由CodeMirror处理）
        });

        // 示例代码数据
        const examples = [
            {
                title: "基础变量和输出",
                description: "学习如何声明变量和使用printf输出",
                code: `int num = 42;
float pi = 3.14159;
vector pos = {1, 2, 3};
string text = "Hello VEX!";

printf("整数: %d\\n", num);
printf("浮点数: %.2f\\n", pi);
printf("向量: %g\\n", pos);
printf("字符串: %s\\n", text);`,
                tags: ["基础", "变量", "输出"]
            },
            {
                title: "四元数基础操作",
                description: "学习四元数的创建、归一化、点积等基本操作",
                code: `// 创建四元数
vector4 q1 = {0, 0, 0.707, 0.707};  // 绕Z轴旋转90度
vector4 q2 = {0.5, 0.5, 0.5, 0.5};  // 另一个四元数

printf("四元数 q1: %g\\n", q1);
printf("四元数 q2: %g\\n", q2);

// 计算长度
float len1 = qlength(q1);
float len2 = qlength(q2);
printf("q1长度: %.3f\\n", len1);
printf("q2长度: %.3f\\n", len2);

// 归一化四元数
vector4 q1_norm = qnormalize(q1);
vector4 q2_norm = qnormalize(q2);
printf("归一化 q1: %g\\n", q1_norm);
printf("归一化 q2: %g\\n", q2_norm);

// 四元数点积
float dot_q = qdot(q1_norm, q2_norm);
printf("四元数点积: %.3f\\n", dot_q);

// 球面线性插值
float t = 0.5;
vector4 q_slerp = qslerp(q1_norm, q2_norm, t);
printf("SLERP插值(t=0.5): %g\\n", q_slerp);

// 使用四元数旋转向量
vector v = {1, 0, 0};
vector v_rotated = qrotate(q1_norm, v);
printf("向量 {1,0,0} 旋转后: %g\\n", v_rotated);`,
                tags: ["四元数", "3D旋转", "数学"]
            },
            {
                title: "噪声函数应用",
                description: "使用各种噪声函数创建程序化纹理",
                code: `// 基础噪声
float noise_val = noise(@P * 5);
printf("基础噪声值: %.3f\\n", noise_val);

// Perlin噪声
vector p = @P * 3;
float perlin_val = pnoise(p, {1,1,1});
printf("Perlin噪声值: %.3f\\n", perlin_val);

// 细胞噪声
float cell_val = cellnoise(@P * 10);
printf("细胞噪声值: %.3f\\n", cell_val);

// 分形布朗运动 (FBM)
float fbm_val = 0;
float amplitude = 1.0;
float frequency = 1.0;
for(int i = 0; i < 5; i++) {
    fbm_val += amplitude * noise(@P * frequency);
    amplitude *= 0.5;
    frequency *= 2.0;
}
printf("FBM噪声值: %.3f\\n", fbm_val);

// 湍流
float turb_val = 0;
amplitude = 1.0;
frequency = 1.0;
for(int i = 0; i < 5; i++) {
    turb_val += amplitude * abs(noise(@P * frequency));
    amplitude *= 0.5;
    frequency *= 2.0;
}
printf("湍流值: %.3f\\n", turb_val);

// Curl噪声
vector curl_val = curlnoise(@P);
printf("Curl噪声向量: %g\\n", curl_val);`,
                tags: ["噪声", "程序化", "纹理"]
            }
        ];

        // VEX函数参考数据（按类别）- 扩展版本
        const functionCategories = {
            'math': {
                name: '数学函数',
                functions: [
                    { 
                        name: 'abs(x)', 
                        desc: '返回x的绝对值', 
                        syntax: 'abs(float x)',
                        example: `float a = -5.3;
float result = abs(a);
printf("abs(-5.3) = %.1f", result);
// 输出: abs(-5.3) = 5.3`
                    },
                    { 
                        name: 'sin(x)', 
                        desc: '计算x的正弦值，x为弧度', 
                        syntax: 'sin(float x)',
                        example: `float angle = 3.14159; // π
float sine = sin(angle);
printf("sin(π) = %.3f", sine);
// 输出: sin(π) = 0.000`
                    },
                    { 
                        name: 'cos(x)', 
                        desc: '计算x的余弦值，x为弧度', 
                        syntax: 'cos(float x)',
                        example: `float angle = 0;
float cosine = cos(angle);
printf("cos(0) = %.1f", cosine);
// 输出: cos(0) = 1.0`
                    },
                    { 
                        name: 'tan(x)', 
                        desc: '计算x的正切值，x为弧度', 
                        syntax: 'tan(float x)',
                        example: `float angle = 0.785398; // π/4
float tangent = tan(angle);
printf("tan(π/4) = %.3f", tangent);
// 输出: tan(π/4) = 1.000`
                    },
                    { 
                        name: 'asin(x)', 
                        desc: '计算x的反正弦值，返回弧度', 
                        syntax: 'asin(float x)',
                        example: `float value = 0.5;
float angle = asin(value);
printf("asin(0.5) = %.3f 弧度", angle);
// 输出: asin(0.5) = 0.524 弧度`
                    },
                    { 
                        name: 'acos(x)', 
                        desc: '计算x的反余弦值，返回弧度', 
                        syntax: 'acos(float x)',
                        example: `float value = 0.5;
float angle = acos(value);
printf("acos(0.5) = %.3f 弧度", angle);
// 输出: acos(0.5) = 1.047 弧度`
                    },
                    { 
                        name: 'atan(x)', 
                        desc: '计算x的反正切值，返回弧度', 
                        syntax: 'atan(float x)',
                        example: `float value = 1.0;
float angle = atan(value);
printf("atan(1.0) = %.3f 弧度", angle);
// 输出: atan(1.0) = 0.785 弧度`
                    },
                    { 
                        name: 'atan2(y, x)', 
                        desc: '计算y/x的反正切值，返回弧度', 
                        syntax: 'atan2(float y, x)',
                        example: `float y = 1.0;
float x = 1.0;
float angle = atan2(y, x);
printf("atan2(1,1) = %.3f 弧度", angle);
// 输出: atan2(1,1) = 0.785 弧度`
                    },
                    { 
                        name: 'sqrt(x)', 
                        desc: '计算x的平方根', 
                        syntax: 'sqrt(float x)',
                        example: `float value = 25.0;
float root = sqrt(value);
printf("sqrt(25) = %.1f", root);
// 输出: sqrt(25) = 5.0`
                    },
                    { 
                        name: 'pow(x, y)', 
                        desc: '计算x的y次幂', 
                        syntax: 'pow(float x, y)',
                        example: `float base = 2.0;
float exponent = 3.0;
float result = pow(base, exponent);
printf("2^3 = %.1f", result);
// 输出: 2^3 = 8.0`
                    },
                    { 
                        name: 'floor(x)', 
                        desc: '返回不大于x的最大整数', 
                        syntax: 'floor(float x)',
                        example: `float num = 3.7;
int result = floor(num);
printf("floor(3.7) = %d", result);
// 输出: floor(3.7) = 3`
                    },
                    { 
                        name: 'ceil(x)', 
                        desc: '返回不小于x的最小整数', 
                        syntax: 'ceil(float x)',
                        example: `float num = 3.2;
int result = ceil(num);
printf("ceil(3.2) = %d", result);
// 输出: ceil(3.2) = 4`
                    },
                    { 
                        name: 'clamp(x, min, max)', 
                        desc: '将x限制在min和max之间', 
                        syntax: 'clamp(float x, min, max)',
                        example: `float value = 15.0;
float clamped = clamp(value, 0, 10);
printf("clamp(15, 0, 10) = %.1f", clamped);
// 输出: clamp(15, 0, 10) = 10.0`
                    },
                    { 
                        name: 'lerp(a, b, t)', 
                        desc: '在a和b之间线性插值', 
                        syntax: 'lerp(float a, b, t)',
                        example: `float start = 0.0;
float end = 10.0;
float t = 0.5;
float interpolated = lerp(start, end, t);
printf("lerp(0, 10, 0.5) = %.1f", interpolated);
// 输出: lerp(0, 10, 0.5) = 5.0`
                    },
                    { 
                        name: 'fit(value, oldmin, oldmax, newmin, newmax)', 
                        desc: '将值从一个范围映射到另一个范围', 
                        syntax: 'fit(float value, oldmin, oldmax, newmin, newmax)',
                        example: `float value = 50.0;
float mapped = fit(value, 0, 100, 0, 1);
printf("fit(50, 0,100, 0,1) = %.2f", mapped);
// 输出: fit(50, 0,100, 0,1) = 0.50`
                    },
                    { 
                        name: 'min(a, b, ...)', 
                        desc: '返回参数中的最小值', 
                        syntax: 'min(float a, b, ...)',
                        example: `float a = 3.5;
float b = 2.7;
float c = 4.1;
float minimum = min(a, b, c);
printf("min(3.5, 2.7, 4.1) = %.1f", minimum);
// 输出: min(3.5, 2.7, 4.1) = 2.7`
                    },
                    { 
                        name: 'max(a, b, ...)', 
                        desc: '返回参数中的最大值', 
                        syntax: 'max(float a, b, ...)',
                        example: `float a = 3.5;
float b = 2.7;
float c = 4.1;
float maximum = max(a, b, c);
printf("max(3.5, 2.7, 4.1) = %.1f", maximum);
// 输出: max(3.5, 2.7, 4.1) = 4.1`
                    },
                    { 
                        name: 'sign(x)', 
                        desc: '返回x的符号：1(正), 0(零), -1(负)', 
                        syntax: 'sign(float x)',
                        example: `float a = 5.0;
float b = -3.0;
float c = 0.0;
printf("sign(5.0) = %.0f", sign(a));
printf("sign(-3.0) = %.0f", sign(b));
printf("sign(0.0) = %.0f", sign(c));
// 输出: sign(5.0) = 1, sign(-3.0) = -1, sign(0.0) = 0`
                    },
                    { 
                        name: 'fmod(x, y)', 
                        desc: '返回x除以y的浮点余数', 
                        syntax: 'fmod(float x, y)',
                        example: `float a = 10.5;
float b = 3.0;
float remainder = fmod(a, b);
printf("fmod(10.5, 3.0) = %.1f", remainder);
// 输出: fmod(10.5, 3.0) = 1.5`
                    },
                    { 
                        name: 'hypot(x, y)', 
                        desc: '计算sqrt(x*x + y*y)，避免溢出', 
                        syntax: 'hypot(float x, y)',
                        example: `float x = 3.0;
float y = 4.0;
float result = hypot(x, y);
printf("hypot(3, 4) = %.1f", result);
// 输出: hypot(3, 4) = 5.0`
                    },
                    { 
                        name: 'cbrt(x)', 
                        desc: '计算x的立方根', 
                        syntax: 'cbrt(float x)',
                        example: `float value = 27.0;
float cube_root = cbrt(value);
printf("cbrt(27) = %.1f", cube_root);
// 输出: cbrt(27) = 3.0`
                    }
                ]
            },
            'vector': {
                name: '向量函数',
                functions: [
                    { 
                        name: 'length(v)', 
                        desc: '计算向量的长度（模）', 
                        syntax: 'length(vector v)',
                        example: `vector v = {3, 4, 0};
float len = length(v);
printf("length({3,4,0}) = %.1f", len);
// 输出: length({3,4,0}) = 5.0`
                    },
                    { 
                        name: 'length2(v)', 
                        desc: '计算向量长度的平方（避免开方运算）', 
                        syntax: 'length2(vector v)',
                        example: `vector v = {3, 4, 0};
float len_sq = length2(v);
printf("length2({3,4,0}) = %.1f", len_sq);
// 输出: length2({3,4,0}) = 25.0`
                    },
                    { 
                        name: 'normalize(v)', 
                        desc: '将向量归一化为单位向量', 
                        syntax: 'normalize(vector v)',
                        example: `vector v = {3, 4, 0};
vector norm = normalize(v);
printf("normalize({3,4,0}) = %g", norm);
// 输出: normalize({3,4,0}) = {0.6, 0.8, 0}`
                    },
                    { 
                        name: 'distance(a, b)', 
                        desc: '计算两点之间的距离', 
                        syntax: 'distance(vector a, b)',
                        example: `vector p1 = {0, 0, 0};
vector p2 = {3, 4, 0};
float dist = distance(p1, p2);
printf("distance({0,0,0}, {3,4,0}) = %.1f", dist);
// 输出: distance({0,0,0}, {3,4,0}) = 5.0`
                    },
                    { 
                        name: 'dot(a, b)', 
                        desc: '计算两个向量的点积', 
                        syntax: 'dot(vector a, b)',
                        example: `vector a = {1, 2, 3};
vector b = {4, 5, 6};
float dot_product = dot(a, b);
printf("dot({1,2,3}, {4,5,6}) = %.1f", dot_product);
// 输出: dot({1,2,3}, {4,5,6}) = 32.0`
                    },
                    { 
                        name: 'cross(a, b)', 
                        desc: '计算两个向量的叉积', 
                        syntax: 'cross(vector a, b)',
                        example: `vector a = {1, 0, 0};
vector b = {0, 1, 0};
vector cross_product = cross(a, b);
printf("cross({1,0,0}, {0,1,0}) = %g", cross_product);
// 输出: cross({1,0,0}, {0,1,0}) = {0, 0, 1}`
                    },
                    { 
                        name: 'rotate(v, angle, axis)', 
                        desc: '将向量绕指定轴旋转指定角度', 
                        syntax: 'rotate(vector v, angle, axis)',
                        example: `vector v = {1, 0, 0};
vector axis = {0, 0, 1};
float angle = 3.14159/2; // 90度
vector rotated = rotate(v, angle, axis);
printf("rotate({1,0,0}, 90°, {0,0,1}) = %g", rotated);
// 输出: rotate({1,0,0}, 90°, {0,0,1}) ≈ {0, 1, 0}`
                    },
                    { 
                        name: 'reflect(I, N)', 
                        desc: '计算入射向量I关于法线N的反射向量', 
                        syntax: 'reflect(vector I, N)',
                        example: `vector I = normalize({1, -1, 0});
vector N = {0, 1, 0};
vector R = reflect(I, N);
printf("反射向量: %g", R);
// 输出: 反射向量 ≈ {1, 1, 0}`
                    },
                    { 
                        name: 'refract(I, N, eta)', 
                        desc: '计算入射向量I的折射向量', 
                        syntax: 'reflect(vector I, N, eta)',
                        example: `vector I = normalize({0, -1, 0});
vector N = {0, 1, 0};
float eta = 1.5; // 折射率
vector T = refract(I, N, eta);
printf("折射向量: %g", T);
// 输出: 折射向量`
                    },
                    { 
                        name: 'orient(from, to)', 
                        desc: '创建从from方向旋转到to方向的矩阵', 
                        syntax: 'orient(vector from, to)',
                        example: `vector from = {1, 0, 0};
vector to = {0, 1, 0};
matrix3 rot = orient(from, to);
printf("从{1,0,0}到{0,1,0}的旋转矩阵: %g", rot);
// 输出: 旋转矩阵`
                    },
                    { 
                        name: 'dihedral(v1, v2)', 
                        desc: '创建从v1旋转到v2的最小旋转矩阵', 
                        syntax: 'dihedral(vector v1, v2)',
                        example: `vector v1 = {1, 0, 0};
vector v2 = {0, 1, 0};
matrix3 rot = dihedral(v1, v2);
printf("从v1到v2的旋转矩阵: %g", rot);
// 输出: 旋转矩阵`
                    }
                ]
            },
            'matrix': {
                name: '矩阵函数',
                functions: [
                    { 
                        name: 'ident()', 
                        desc: '创建单位矩阵', 
                        syntax: 'ident()',
                        example: `matrix3 m = ident();
printf("单位矩阵: %g", m);
// 输出: 单位矩阵: {{1,0,0}, {0,1,0}, {0,0,1}}`
                    },
                    { 
                        name: 'invert(m)', 
                        desc: '计算矩阵的逆矩阵', 
                        syntax: 'invert(matrix m)',
                        example: `matrix2 m = {{2,0}, {0,2}};
matrix2 inv_m = invert(m);
printf("逆矩阵: %g", inv_m);
// 输出: 逆矩阵: {{0.5,0}, {0,0.5}}`
                    },
                    { 
                        name: 'transpose(m)', 
                        desc: '计算矩阵的转置矩阵', 
                        syntax: 'transpose(matrix m)',
                        example: `matrix3 m = {{1,2,3}, {4,5,6}, {7,8,9}};
matrix3 t = transpose(m);
printf("转置矩阵: %g", t);
// 输出: 转置矩阵: {{1,4,7}, {2,5,8}, {3,6,9}}`
                    },
                    { 
                        name: 'determinant(m)', 
                        desc: '计算矩阵的行列式', 
                        syntax: 'determinant(matrix m)',
                        example: `matrix2 m = {{2,1}, {1,2}};
float det = determinant(m);
printf("行列式: %.1f", det);
// 输出: 行列式: 3.0`
                    },
                    { 
                        name: 'maketransform(tx, ty, tz, rx, ry, rz, sx, sy, sz)', 
                        desc: '创建变换矩阵', 
                        syntax: 'maketransform(float tx, ty, tz, rx, ry, rz, sx, sy, sz)',
                        example: `matrix m = maketransform(1, 2, 3, 45, 30, 0, 1, 1, 1);
printf("变换矩阵: %g", m);
// 输出: 变换矩阵`
                    },
                    { 
                        name: 'cracktransform(xOrd, rOrd, tOrd, matrix)', 
                        desc: '分解变换矩阵', 
                        syntax: 'cracktransform(string xOrd, rOrd, tOrd, matrix)',
                        example: `matrix m = maketransform(1,2,3,45,30,0,1,1,1);
vector t, r, s;
cracktransform("trs", "XYZ", "XYZ", m, t, r, s);
printf("平移: %g\\n旋转: %g\\n缩放: %g", t, r, s);
// 输出: 平移: {1,2,3} 旋转: {45,30,0} 缩放: {1,1,1}`
                    },
                    { 
                        name: 'outerproduct(a, b)', 
                        desc: '计算两个向量的外积（矩阵）', 
                        syntax: 'outerproduct(vector a, b)',
                        example: `vector a = {1, 2, 3};
vector b = {4, 5, 6};
matrix3 m = outerproduct(a, b);
printf("外积矩阵: %g", m);
// 输出: 外积矩阵`
                    },
                    { 
                        name: 'trace(m)', 
                        desc: '计算矩阵的迹（对角线元素之和）', 
                        syntax: 'trace(matrix m)',
                        example: `matrix3 m = {{1,2,3}, {4,5,6}, {7,8,9}};
float tr = trace(m);
printf("矩阵迹: %.1f", tr);
// 输出: 矩阵迹: 15.0`
                    }
                ]
            },
            'array': {
                name: '数组函数',
                functions: [
                    { 
                        name: 'len(array)', 
                        desc: '返回数组的长度', 
                        syntax: 'len(array)',
                        example: `float arr[] = {1.1, 2.2, 3.3, 4.4};
int length = len(arr);
printf("数组长度: %d", length);
// 输出: 数组长度: 4`
                    },
                    { 
                        name: 'append(array, value)', 
                        desc: '向数组末尾添加元素', 
                        syntax: 'append(array, value)',
                        example: `float arr[] = {1, 2, 3};
append(arr, 4);
printf("添加后数组: %g", arr);
// 输出: 添加后数组: {1, 2, 3, 4}`
                    },
                    { 
                        name: 'sort(array)', 
                        desc: '对数组进行排序', 
                        syntax: 'sort(array)',
                        example: `float arr[] = {3, 1, 4, 2};
float sorted_arr[] = sort(arr);
printf("排序后: %g", sorted_arr);
// 输出: 排序后: {1, 2, 3, 4}`
                    },
                    { 
                        name: 'reverse(array)', 
                        desc: '反转数组元素的顺序', 
                        syntax: 'reverse(array)',
                        example: `float arr[] = {1, 2, 3, 4};
float reversed[] = reverse(arr);
printf("反转后: %g", reversed);
// 输出: 反转后: {4, 3, 2, 1}`
                    },
                    { 
                        name: 'sum(array)', 
                        desc: '计算数组所有元素的总和', 
                        syntax: 'sum(array)',
                        example: `float arr[] = {1, 2, 3, 4};
float total = sum(arr);
printf("数组总和: %.1f", total);
// 输出: 数组总和: 10.0`
                    },
                    { 
                        name: 'avg(array)', 
                        desc: '计算数组所有元素的平均值', 
                        syntax: 'avg(array)',
                        example: `float arr[] = {1, 2, 3, 4, 5};
float average = avg(arr);
printf("数组平均值: %.1f", average);
// 输出: 数组平均值: 3.0`
                    },
                    { 
                        name: 'find(array, value)', 
                        desc: '在数组中查找值，返回索引，找不到返回-1', 
                        syntax: 'find(array, value)',
                        example: `float arr[] = {10, 20, 30, 40};
int index = find(arr, 30);
printf("30在数组中的索引: %d", index);
// 输出: 30在数组中的索引: 2`
                    },
                    { 
                        name: 'insert(array, index, value)', 
                        desc: '在指定索引处插入元素', 
                        syntax: 'insert(array, index, value)',
                        example: `float arr[] = {1, 2, 4};
insert(arr, 2, 3);  // 在索引2处插入3
printf("插入后: %g", arr);
// 输出: 插入后: {1, 2, 3, 4}`
                    },
                    { 
                        name: 'removeindex(array, index)', 
                        desc: '移除指定索引处的元素', 
                        syntax: 'removeindex(array, index)',
                        example: `float arr[] = {1, 2, 3, 4};
removeindex(arr, 2);  // 移除索引2处的元素
printf("移除后: %g", arr);
// 输出: 移除后: {1, 2, 4}`
                    },
                    { 
                        name: 'slice(array, start, end)', 
                        desc: '提取数组切片', 
                        syntax: 'slice(array, start, end)',
                        example: `float arr[] = {1, 2, 3, 4, 5};
float sliced[] = slice(arr, 1, 4);
printf("切片[1:4]: %g", sliced);
// 输出: 切片[1:4]: {2, 3, 4}`
                    },
                    { 
                        name: 'concatenate(a, b)', 
                        desc: '连接两个数组', 
                        syntax: 'concatenate(array a, b)',
                        example: `float a[] = {1, 2, 3};
float b[] = {4, 5, 6};
float combined[] = concatenate(a, b);
printf("连接后: %g", combined);
// 输出: 连接后: {1, 2, 3, 4, 5, 6}`
                    }
                ]
            },
            'string': {
                name: '字符串函数',
                functions: [
                    { 
                        name: 'strlen(string)', 
                        desc: '返回字符串的长度', 
                        syntax: 'strlen(string)',
                        example: `string str = "Hello VEX";
int length = strlen(str);
printf("字符串长度: %d", length);
// 输出: 字符串长度: 9`
                    },
                    { 
                        name: 'toupper(string)', 
                        desc: '将字符串转换为大写', 
                        syntax: 'toupper(string)',
                        example: `string str = "Hello Vex";
string upper = toupper(str);
printf("大写: %s", upper);
// 输出: 大写: HELLO VEX`
                    },
                    { 
                        name: 'tolower(string)', 
                        desc: '将字符串转换为小写', 
                        syntax: 'tolower(string)',
                        example: `string str = "HELLO VEX";
string lower = tolower(str);
printf("小写: %s", lower);
// 输出: 小写: hello vex`
                    },
                    { 
                        name: 'split(string, delimiter)', 
                        desc: '按分隔符分割字符串为数组', 
                        syntax: 'split(string, delimiter)',
                        example: `string str = "apple,banana,cherry";
string fruits[] = split(str, ",");
printf("分割结果: %g", fruits);
// 输出: 分割结果: {"apple", "banana", "cherry"}`
                    },
                    { 
                        name: 'join(array, delimiter)', 
                        desc: '用分隔符连接数组元素为字符串', 
                        syntax: 'join(array, delimiter)',
                        example: `string arr[] = {"apple", "banana", "cherry"};
string joined = join(arr, "|");
printf("连接结果: %s", joined);
// 输出: 连接结果: apple|banana|cherry`
                    },
                    { 
                        name: 'substr(string, start, length)', 
                        desc: '提取子字符串', 
                        syntax: 'substr(string, start, length)',
                        example: `string str = "Hello World";
string sub = substr(str, 6, 5);
printf("子字符串: %s", sub);
// 输出: 子字符串: World`
                    },
                    { 
                        name: 'strfind(string, substr)', 
                        desc: '查找子字符串位置，找不到返回-1', 
                        syntax: 'strfind(string, substr)',
                        example: `string str = "Hello World";
int pos = strfind(str, "World");
printf("'World'位置: %d", pos);
// 输出: 'World'位置: 6`
                    },
                    { 
                        name: 'replace(string, old, new)', 
                        desc: '替换字符串中的子串', 
                        syntax: 'replace(string, old, new)',
                        example: `string str = "Hello World";
string replaced = replace(str, "World", "VEX");
printf("替换后: %s", replaced);
// 输出: 替换后: Hello VEX`
                    },
                    { 
                        name: 'strstrip(string)', 
                        desc: '去除字符串两端的空白字符', 
                        syntax: 'strstrip(string)',
                        example: `string str = "  Hello VEX  ";
string stripped = strstrip(str);
printf("去除空白: '%s'", stripped);
// 输出: 去除空白: 'Hello VEX'`
                    },
                    { 
                        name: 'match(string, pattern)', 
                        desc: '正则表达式匹配，返回匹配结果', 
                        syntax: 'match(string, pattern)',
                        example: `string str = "Hello123";
string result = match(str, "[A-Za-z]+");
printf("匹配字母部分: %s", result);
// 输出: 匹配字母部分: Hello`
                    }
                ]
            },
            'quaternion': {
                name: '四元数函数',
                functions: [
                    { 
                        name: 'quaternion(w, x, y, z)', 
                        desc: '创建四元数', 
                        syntax: 'quaternion(float w, x, y, z)',
                        example: `vector4 q = quaternion(0.707, 0, 0, 0.707);
printf("四元数: %g", q);
// 输出: 四元数: {0.707, 0, 0, 0.707}`
                    },
                    { 
                        name: 'qconvert(matrix)', 
                        desc: '将旋转矩阵转换为四元数', 
                        syntax: 'qconvert(matrix m)',
                        example: `matrix3 m = ident();
vector4 q = qconvert(m);
printf("单位矩阵对应的四元数: %g", q);
// 输出: 单位矩阵对应的四元数: {1, 0, 0, 0}`
                    },
                    { 
                        name: 'qmultiply(q1, q2)', 
                        desc: '四元数乘法', 
                        syntax: 'qmultiply(vector4 q1, q2)',
                        example: `vector4 q1 = {0.707, 0, 0, 0.707};
vector4 q2 = {0.707, 0, 0.707, 0};
vector4 q3 = qmultiply(q1, q2);
printf("四元数乘积: %g", q3);
// 输出: 四元数乘积`
                    },
                    { 
                        name: 'qslerp(q1, q2, t)', 
                        desc: '四元数球面线性插值', 
                        syntax: 'qslerp(vector4 q1, q2, t)',
                        example: `vector4 q1 = {1, 0, 0, 0};
vector4 q2 = {0.707, 0, 0, 0.707};
vector4 q = qslerp(q1, q2, 0.5);
printf("SLERP插值: %g", q);
// 输出: SLERP插值`
                    },
                    { 
                        name: 'qinvert(q)', 
                        desc: '四元数求逆（共轭）', 
                        syntax: 'qinvert(vector4 q)',
                        example: `vector4 q = {0.707, 0, 0, 0.707};
vector4 q_inv = qinvert(q);
printf("四元数逆: %g", q_inv);
// 输出: 四元数逆: {0.707, 0, 0, -0.707}`
                    },
                    { 
                        name: 'qrotate(q, v)', 
                        desc: '用四元数旋转向量', 
                        syntax: 'qrotate(vector4 q, vector v)',
                        example: `vector4 q = {0.707, 0, 0, 0.707}; // 绕Z轴旋转90度
vector v = {1, 0, 0};
vector v_rotated = qrotate(q, v);
printf("旋转后向量: %g", v_rotated);
// 输出: 旋转后向量 ≈ {0, 1, 0}`
                    },
                    { 
                        name: 'qdot(q1, q2)', 
                        desc: '四元数点积', 
                        syntax: 'qdot(vector4 q1, q2)',
                        example: `vector4 q1 = {0.707, 0, 0, 0.707};
vector4 q2 = {0.5, 0.5, 0.5, 0.5};
float dot_q = qdot(q1, q2);
printf("四元数点积: %.3f", dot_q);
// 输出: 四元数点积: 0.707`
                    },
                    { 
                        name: 'qlength(q)', 
                        desc: '四元数长度', 
                        syntax: 'qlength(vector4 q)',
                        example: `vector4 q = {0.5, 0.5, 0.5, 0.5};
float len = qlength(q);
printf("四元数长度: %.3f", len);
// 输出: 四元数长度: 1.000`
                    },
                    { 
                        name: 'qnormalize(q)', 
                        desc: '四元数归一化', 
                        syntax: 'qnormalize(vector4 q)',
                        example: `vector4 q = {1, 2, 3, 4};
vector4 q_norm = qnormalize(q);
printf("归一化四元数: %g", q_norm);
// 输出: 归一化四元数`
                    },
                    { 
                        name: 'qfromeuler(rx, ry, rz)', 
                        desc: '从欧拉角创建四元数', 
                        syntax: 'qfromeuler(float rx, ry, rz)',
                        example: `vector4 q = qfromeuler(0, 90, 0); // 绕Y轴旋转90度
printf("欧拉角(0,90,0)对应的四元数: %g", q);
// 输出: 四元数`
                    },
                    { 
                        name: 'qfromaxisangle(axis, angle)', 
                        desc: '从轴角创建四元数', 
                        syntax: 'qfromaxisangle(vector axis, float angle)',
                        example: `vector axis = {0, 0, 1};
float angle = 3.14159/2; // 90度
vector4 q = qfromaxisangle(axis, angle);
printf("绕Z轴旋转90度的四元数: %g", q);
// 输出: 四元数 ≈ {0.707, 0, 0, 0.707}`
                    },
                    { 
                        name: 'qtoeuler(q)', 
                        desc: '四元数转换为欧拉角', 
                        syntax: 'qtoeuler(vector4 q)',
                        example: `vector4 q = {0.707, 0, 0, 0.707};
vector euler = qtoeuler(q);
printf("四元数对应的欧拉角: %g", euler);
// 输出: 欧拉角 ≈ {0, 0, 90}`
                    },
                    { 
                        name: 'qtomatrix(q)', 
                        desc: '四元数转换为旋转矩阵', 
                        syntax: 'qtomatrix(vector4 q)',
                        example: `vector4 q = {0.707, 0, 0, 0.707};
matrix3 m = qtomatrix(q);
printf("四元数对应的旋转矩阵: %g", m);
// 输出: 旋转矩阵`
                    }
                ]
            },
            'random': {
                name: '随机函数',
                functions: [
                    { 
                        name: 'random()', 
                        desc: '返回0到1之间的随机浮点数', 
                        syntax: 'random()',
                        example: `float r = random();
printf("随机数: %.3f", r);
// 输出: 随机数: 0.xxx`
                    },
                    { 
                        name: 'random(min, max)', 
                        desc: '返回指定范围内的随机浮点数', 
                        syntax: 'random(float min, max)',
                        example: `float r = random(10, 20);
printf("10-20之间的随机数: %.1f", r);
// 输出: 10-20之间的随机数: xx.x`
                    },
                    { 
                        name: 'rand(seed)', 
                        desc: '基于种子的确定性随机数', 
                        syntax: 'rand(int seed)',
                        example: `float r1 = rand(42);
float r2 = rand(42);
printf("相同种子的随机数1: %.3f", r1);
printf("相同种子的随机数2: %.3f", r2);
// 输出: 两个随机数相同`
                    },
                    { 
                        name: 'random_fhash(position)', 
                        desc: '基于位置哈希的随机数', 
                        syntax: 'random_fhash(vector position)',
                        example: `vector pos = {1.5, 2.3, 3.7};
float r = random_fhash(pos);
printf("位置哈希随机数: %.3f", r);
// 输出: 位置哈希随机数`
                    },
                    { 
                        name: 'random_ihash(seed)', 
                        desc: '基于整数哈希的随机数', 
                        syntax: 'random_ihash(int seed)',
                        example: `int seed = 123;
float r = random_ihash(seed);
printf("整数哈希随机数: %.3f", r);
// 输出: 整数哈希随机数`
                    },
                    { 
                        name: 'random_shash(string)', 
                        desc: '基于字符串哈希的随机数', 
                        syntax: 'random_shash(string str)',
                        example: `string str = "hello";
float r = random_shash(str);
printf("字符串哈希随机数: %.3f", r);
// 输出: 字符串哈希随机数`
                    },
                    { 
                        name: 'random_poisson(mean)', 
                        desc: '泊松分布随机数', 
                        syntax: 'random_poisson(float mean)',
                        example: `float r = random_poisson(5.0);
printf("泊松分布随机数(mean=5): %.0f", r);
// 输出: 泊松分布随机数`
                    }
                ]
            },
            'noise': {
                name: '噪声函数',
                functions: [
                    { 
                        name: 'noise(position)', 
                        desc: 'Perlin噪声，返回-1到1的值', 
                        syntax: 'noise(vector position)',
                        example: `vector pos = {1.5, 2.3, 3.7};
float n = noise(pos);
printf("Perlin噪声值: %.3f", n);
// 输出: Perlin噪声值: x.xxx`
                    },
                    { 
                        name: 'pnoise(position, period)', 
                        desc: '周期性Perlin噪声', 
                        syntax: 'pnoise(vector position, period)',
                        example: `vector pos = {1.5, 2.3, 3.7};
vector period = {10, 10, 10};
float n = pnoise(pos, period);
printf("周期性噪声值: %.3f", n);
// 输出: 周期性噪声值`
                    },
                    { 
                        name: 'anoise(position)', 
                        desc: '各向异性Perlin噪声', 
                        syntax: 'anoise(vector position)',
                        example: `vector pos = {1.5, 2.3, 3.7};
float n = anoise(pos);
printf("各向异性噪声值: %.3f", n);
// 输出: 各向异性噪声值`
                    },
                    { 
                        name: 'curlnoise(position)', 
                        desc: 'Curl噪声，返回向量场', 
                        syntax: 'curlnoise(vector position)',
                        example: `vector pos = {1.5, 2.3, 3.7};
vector curl = curlnoise(pos);
printf("Curl噪声向量: %g", curl);
// 输出: Curl噪声向量`
                    },
                    { 
                        name: 'cellnoise(position)', 
                        desc: '细胞噪声（Voronoi噪声）', 
                        syntax: 'cellnoise(vector position)',
                        example: `vector pos = {1.5, 2.3, 3.7};
float n = cellnoise(pos);
printf("细胞噪声值: %.3f", n);
// 输出: 细胞噪声值`
                    },
                    { 
                        name: 'cellnoise3(position)', 
                        desc: '三维细胞噪声，返回距离和位置', 
                        syntax: 'cellnoise3(vector position)',
                        example: `vector pos = {1.5, 2.3, 3.7};
vector cell_info = cellnoise3(pos);
printf("细胞噪声信息: %g", cell_info);
// 输出: 细胞噪声信息`
                    },
                    { 
                        name: 'snoise(position)', 
                        desc: 'Simplex噪声', 
                        syntax: 'snoise(vector position)',
                        example: `vector pos = {1.5, 2.3, 3.7};
float n = snoise(pos);
printf("Simplex噪声值: %.3f", n);
// 输出: Simplex噪声值`
                    },
                    { 
                        name: 'vsnoise(position)', 
                        desc: '向量Simplex噪声', 
                        syntax: 'vsnoise(vector position)',
                        example: `vector pos = {1.5, 2.3, 3.7};
vector n = vsnoise(pos);
printf("向量Simplex噪声: %g", n);
// 输出: 向量Simplex噪声`
                    },
                    { 
                        name: 'fbm(position, octaves, lacunarity, gain)', 
                        desc: '分形布朗运动', 
                        syntax: 'fbm(vector position, octaves, lacunarity, gain)',
                        example: `vector pos = {1.5, 2.3, 3.7};
float n = fbm(pos, 5, 2.0, 0.5);
printf("FBM噪声值: %.3f", n);
// 输出: FBM噪声值`
                    },
                    { 
                        name: 'turbulence(position, octaves)', 
                        desc: '湍流噪声', 
                        syntax: 'turbulence(vector position, octaves)',
                        example: `vector pos = {1.5, 2.3, 3.7};
float n = turbulence(pos, 5);
printf("湍流噪声值: %.3f", n);
// 输出: 湍流噪声值`
                    }
                ]
            },
            'conversion': {
                name: '转换函数',
                functions: [
                    { 
                        name: 'deg(radians)', 
                        desc: '将弧度转换为角度', 
                        syntax: 'deg(float radians)',
                        example: `float radians = 3.14159; // π
float degrees = deg(radians);
printf("π 弧度 = %.1f°", degrees);
// 输出: π 弧度 = 180.0°`
                    },
                    { 
                        name: 'rad(degrees)', 
                        desc: '将角度转换为弧度', 
                        syntax: 'rad(float degrees)',
                        example: `float degrees = 180;
float radians = rad(degrees);
printf("180° = %.3f 弧度", radians);
// 输出: 180° = 3.142 弧度`
                    },
                    { 
                        name: 'toNDC(P, camera)', 
                        desc: '将世界坐标转换为NDC坐标', 
                        syntax: 'toNDC(vector P, camera)',
                        example: `// 需要相机参数
vector P = {0, 0, 10};
// vector ndc = toNDC(P, cam);
printf("NDC转换函数");
// 输出: 需要实际相机参数`
                    },
                    { 
                        name: 'hsvtorgb(hsv)', 
                        desc: '将HSV颜色转换为RGB颜色', 
                        syntax: 'hsvtorgb(vector hsv)',
                        example: `vector hsv = {0.0, 1.0, 1.0}; // 红色
vector rgb = hsvtorgb(hsv);
printf("HSV(0,1,1) -> RGB: %g", rgb);
// 输出: HSV(0,1,1) -> RGB: {1, 0, 0}`
                    },
                    { 
                        name: 'rgbtohsv(rgb)', 
                        desc: '将RGB颜色转换为HSV颜色', 
                        syntax: 'rgbtohsv(vector rgb)',
                        example: `vector rgb = {1, 0, 0}; // 红色
vector hsv = rgbtohsv(rgb);
printf("RGB(1,0,0) -> HSV: %g", hsv);
// 输出: RGB(1,0,0) -> HSV: {0, 1, 1}`
                    },
                    { 
                        name: 'rgbtolab(rgb)', 
                        desc: '将RGB颜色转换为Lab颜色空间', 
                        syntax: 'rgbtolab(vector rgb)',
                        example: `vector rgb = {1, 0, 0};
vector lab = rgbtolab(rgb);
printf("RGB转Lab: %g", lab);
// 输出: RGB转Lab`
                    },
                    { 
                        name: 'labtorgb(lab)', 
                        desc: '将Lab颜色转换为RGB颜色', 
                        syntax: 'labtorgb(vector lab)',
                        example: `vector lab = {53.24, 80.09, 67.20}; // 红色
vector rgb = labtorgb(lab);
printf("Lab转RGB: %g", rgb);
// 输出: Lab转RGB ≈ {1, 0, 0}`
                    },
                    { 
                        name: 'itoa(int)', 
                        desc: '将整数转换为字符串', 
                        syntax: 'itoa(int)',
                        example: `int number = 123;
string str = itoa(number);
printf("整数123转换为字符串: %s", str);
// 输出: 整数123转换为字符串: 123`
                    },
                    { 
                        name: 'atoi(string)', 
                        desc: '将字符串转换为整数', 
                        syntax: 'atoi(string)',
                        example: `string str = "456";
int number = atoi(str);
printf("字符串'456'转换为整数: %d", number);
// 输出: 字符串'456'转换为整数: 456`
                    },
                    { 
                        name: 'ftoa(float)', 
                        desc: '将浮点数转换为字符串', 
                        syntax: 'ftoa(float)',
                        example: `float number = 3.14159;
string str = ftoa(number);
printf("浮点数转换为字符串: %s", str);
// 输出: 浮点数转换为字符串: 3.14159`
                    },
                    { 
                        name: 'atof(string)', 
                        desc: '将字符串转换为浮点数', 
                        syntax: 'atof(string)',
                        example: `string str = "3.14159";
float number = atof(str);
printf("字符串转换为浮点数: %.5f", number);
// 输出: 字符串转换为浮点数: 3.14159`
                    },
                    { 
                        name: 'ch(index)', 
                        desc: '返回ASCII字符', 
                        syntax: 'ch(int index)',
                        example: `string char = ch(65); // ASCII 65 = 'A'
printf("ASCII 65对应字符: %s", char);
// 输出: ASCII 65对应字符: A`
                    },
                    { 
                        name: 'ord(char)', 
                        desc: '返回字符的ASCII码', 
                        syntax: 'ord(string char)',
                        example: `int code = ord("A");
printf("'A'的ASCII码: %d", code);
// 输出: 'A'的ASCII码: 65`
                    }
                ]
            }
        };

        // 加载示例代码
        function loadExamples() {
            examplesGrid.innerHTML = '';
            
            examples.forEach((example, index) => {
                const exampleCard = document.createElement('div');
                exampleCard.className = 'example-card';
                exampleCard.dataset.index = index;
                
                // 生成标签HTML
                const tagsHtml = example.tags.map(tag => 
                    `<span class="example-tag">${tag}</span>`
                ).join('');
                
                exampleCard.innerHTML = `
                    <div class="example-title">
                        <i class="fas fa-code"></i>
                        ${example.title}
                    </div>
                    <div class="example-desc">${example.description}</div>
                    <div class="example-tags">${tagsHtml}</div>
                `;
                
                exampleCard.addEventListener('click', () => {
                    editor.setValue(example.code);
                    outputInfo.innerHTML = `<div class="success">✓ 已加载"${example.title}"示例代码</div>`;
                    
                    // 滚动到编辑器
                    document.querySelector('.editor-section').scrollIntoView({ 
                        behavior: 'smooth',
                        block: 'start'
                    });
                });
                
                examplesGrid.appendChild(exampleCard);
            });
        }

        // 加载函数参考标签页
        function loadFunctionTabs() {
            functionTabs.innerHTML = '';
            
            Object.keys(functionCategories).forEach(categoryId => {
                const category = functionCategories[categoryId];
                const tab = document.createElement('div');
                tab.className = 'tab';
                tab.textContent = category.name;
                tab.dataset.tab = categoryId + '-tab';
                
                tab.addEventListener('click', () => {
                    // 移除所有标签的active类
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // 激活当前标签
                    tab.classList.add('active');
                    tabContents[categoryId + '-tab'].classList.add('active');
                    
                    // 加载对应的函数
                    loadFunctionsForCategory(categoryId);
                });
                
                functionTabs.appendChild(tab);
            });
            
            // 激活第一个标签
            if (functionTabs.firstChild) {
                functionTabs.firstChild.classList.add('active');
                loadFunctionsForCategory('math');
            }
        }

        // 加载指定类别的函数
        function loadFunctionsForCategory(categoryId) {
            const containerId = categoryId + 'Functions';
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const category = functionCategories[categoryId];
            container.innerHTML = '';
            
            category.functions.forEach(func => {
                const funcItem = document.createElement('div');
                funcItem.className = 'function-item';
                
                // 点击函数项将其插入编辑器
                funcItem.addEventListener('click', () => {
                    const cursor = editor.getCursor();
                    editor.replaceRange(func.name.split('(')[0] + '(', cursor);
                    editor.focus();
                });
                
                // 创建示例代码的HTML
                const exampleHtml = func.example ? 
                    `<div class="function-example">
                        <div class="example-comment">// 示例:</div>
                        <div class="example-code">${func.example.replace(/\n/g, '<br>')}</div>
                    </div>` : '';
                
                funcItem.innerHTML = `
                    <div class="function-header">
                        <div class="function-name">${func.name}</div>
                        <span class="function-category">${category.name}</span>
                    </div>
                    <div class="function-desc">${func.desc}</div>
                    <div class="function-syntax">${func.syntax}</div>
                    ${exampleHtml}
                    <div class="function-actions">
                        <div class="function-btn insert-btn">插入到编辑器</div>
                        <div class="function-btn run-example-btn">运行示例</div>
                    </div>
                `;
                
                // 添加按钮事件
                const insertBtn = funcItem.querySelector('.insert-btn');
                const runExampleBtn = funcItem.querySelector('.run-example-btn');
                
                insertBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const cursor = editor.getCursor();
                    editor.replaceRange(func.name.split('(')[0] + '(', cursor);
                    editor.focus();
                    outputInfo.innerHTML = `<div class="success">✓ 已插入函数 ${func.name}</div>`;
                });
                
                if (func.example) {
                    runExampleBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        editor.setValue(func.example);
                        runCode();
                        outputInfo.innerHTML = `<div class="success">✓ 已加载并运行 ${func.name} 示例</div>`;
                    });
                }
                
                container.appendChild(funcItem);
            });
        }

        // 初始化
        loadExamples();
        loadFunctionTabs();
        
        // 添加编辑器自动提示
        editor.on('keyup', (cm, event) => {
            // 在输入点号或字母后显示提示
            if (event.key === '.' || event.key.length === 1 && /[a-zA-Z]/.test(event.key)) {
                const cursor = cm.getCursor();
                const token = cm.getTokenAt(cursor);
                
                // 如果当前词以字母开头且长度>=2，显示提示
                if (token.string.length >= 2 && /^[a-zA-Z]/.test(token.string)) {
                    cm.showHint({
                        hint: CodeMirror.hint.vex,
                        completeSingle: false
                    });
                }
            }
        });

        // 页面加载完成后执行
        window.addEventListener('DOMContentLoaded', () => {
            // 添加欢迎信息
            setTimeout(() => {
                outputInfo.innerHTML = '<div class="success">✓ VEX练习平台已就绪！使用Ctrl+Space获取代码提示，Ctrl+Enter运行代码。</div>';
            }, 1000);
        });
    </script>
</body>
</html>
